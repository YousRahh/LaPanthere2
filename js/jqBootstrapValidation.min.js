(function ($) {
    varcreatedelements: []; vardefaults: {
        options: {
            prependExistingHelpBlock: false, sniffHtml: true,// sniff for required,maxlength,etc preventSubmit: true,// stop the form submit event from firing if validation fails submitError: false,// function called if there is an error when trying to submit submitSuccess: false,// function called just before a successful submit event is sent to the server semanticallyStrict: false,// set to true to tidy up generated HTML output autoAdd: { helpBlocks: true},filter: function (){ifthisdatavalidationmincheckedmessagemessage:$this.data(validationMincheckedMessage)}// ---------------------------------------------------------
// MAXCHECKED
// ---------------------------------------------------------
if ($this.attr(maxchecked) !== undefined) { message: "Too many options checked; Maximum of '" + $this.attr(maxchecked) + "' required<!-- data-validation-maxchecked-message to override -->"; ifthisdatavalidationmaxcheckedmessagemessage: $this.data(validationMaxcheckedMessage) }// =============================================================
            // COLLECT VALIDATOR NAMES
            // =============================================================
            // Get named validators
            if ($this.data(validation) !== undefined) { validatornames: $this.data(validation).split(,) }, ajax: {
                name: ajax, init: function ($this, name) {
                    return { validatorName: name, url: $this.data(validation + name + "Ajax"), lastValue: $this.val(), lastValid: true, lastFinished: true }, validate: function ($this, value, validator) {
                        ifvalidatorlastvalue:== +value && validator.lastFinished === true) { return validator.lastValid === false } if (validator.lastFinished === true) {
                            validatorlastvalue: value; validatorlastvalid: true; validatorlastfinished: false; $ajaxurl: validator.url, data: value = + value + & field= + $this.attr(name), dataType: json, success: function (data) {
                                if (+validator.lastValue === "" + data.value) { validator.lastValid = !!(data.valid); ifdatamessagevalidatormessage: data.message }, regex: {
                                    name: regex, init: function ($this, name) {
                                        return { regex: regexFromString($this.data(validation + name + "Regex")) }, required: {
                                            name: required, init: function ($this, name) {
                                                return {}, validate: function ($this, value, validator) { returnvaluelength:== 0 && !validator.negative) || !!(value.length > 0 && validator.negative) }, match: {
                                                    name: match, init: function ($this, name) { var element = $this.parents(form).first().find([name =\" + $this.data(validation + name + "Match") + "\"]").first(); elementbindvalidationvalidationfunctionthistriggerchangevalidationsubmitting: true });
                                                    return { "element:element},validate: function ($this,value,validator){returnvalue:= validator.element.val() && ! validator.negative) || (value === validator.element.val() && validator.negative)},max:{name:max,init: function ($this,name) { return {max: $this.data(validation + name + "Max")},validate: function ($this,value,validator){returnparsefloatvalue10parsefloatvalidatormax10validatornegativeparsefloatvalue10:parseFloat(validator.max,10) && validator.negative)},min:{name:min,init: function ($this,name) { return {min: $this.data(validation + name + "Min")},validate: function ($this,value,validator){returnparsefloatvalueparsefloatvalidatorminvalidatornegativeparsefloatvalue:parseFloat(validator.min) && validator.negative)},maxlength:{name:maxlength,init: function ($this,name) { return {maxlength: $this.data(validation + name + "Maxlength")},validate: function ($this,value,validator){returnvaluelengthvalidatormaxlengthvalidatornegativevaluelength:validator.maxlength) && validator.negative)},minlength:{name:minlength,init: function ($this,name) { return {minlength: $this.data(validation + name + "Minlength")},validate: function ($this,value,validator){returnvaluelengthvalidatorminlengthvalidatornegativevaluelength:validator.minlength) && validator.negative)},maxchecked:{name:maxchecked,init: function ($this,name) { var elements = $this.parents(form).first().find([name=\" + $this.attr(name) + "\"]"); elementsbindclickvalidationfunctionthistriggerchangevalidationincludeempty: true });
                                                    return { maxchecked: $this.data(validation + name + "Maxchecked"), elements: elements }, validate: function ($this, value, validator) { returnvalidatorelementsfilter:checked").length > validator.maxchecked && ! validator.negative)\A						|| (validator.elements.filter(":checked").length <= validator.maxchecked && validator.negative);\A },\A blockSubmit: true\A },\A minchecked: {\A name: "minchecked",\A				init: function ($this,name) {\A					var elements = $this.parents("form).first().find([name =\"" + $this.attr("name") + "\"]"); \A					elements.bind("click.validation", function () { \A						$this.trigger("change.validation", { includeEmpty: true }); \A }); \A					return { minchecked: $this.data("validation" + name + "Minchecked"), elements: elements }; \A }, \A				validate: function ($this, value, validator) { \A					return (validator.elements.filter(":checked").length < validator.minchecked && !validator.negative) \A || (validator.elements.filter(":checked").length >= validator.minchecked && validator.negative); \A }, \A blockSubmit: true\A
                                                } \A
                                            }, \A builtInValidators: { \A email: { \A name: "Email", \A				type: "shortcut", \A				shortcut: "validemail"\A }, \A			validemail: { \A				name: "Validemail", \A				type: "regex", \A				regex: "[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\.[A-Za-z]{2,10}