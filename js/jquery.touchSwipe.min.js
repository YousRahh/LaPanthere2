! function (factory) {
    "function:= typeof define && define.amd && define.amd.jQuery ? define(["jquery"],factory) : factory(undefined != typeof module && module.exports ? require(jquery) : jQuery)}(function($){functioninitoptionsreturnoptionsvoid0:= options.allowPageScroll || void 0 === options.swipe && void 0 === options.swipeStatus || (options.allowPageScroll = NONE),void 0 !== options.click && void 0 === options.tap && (options.tap = options.click),options || (options = {}),options = $.extend({},$.fn.swipe.defaults,options),this.each(function() { var $this = $(this),plugin = $this.data(PLUGIN_NS); plugin || (plugin = new TouchSwipe(this,options),$this.data(PLUGIN_NS,plugin)) })}function TouchSwipe(element,options){functiontouchstartjqeventifgettouchinprogressjqeventtargetclosestoptionsexcludedelementselementlength0varevent:jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;ifeventpointertypemouse:event.pointerType || 0 != options.fallbackToMouseEvents) { var ret,touches = event.touches,evt = touches ? touches[0] : event;returnphase:PHASE_START,touches ? fingerCount = touches.length : options.preventDefaultEvents !== !1 && jqEvent.preventDefault(),distance = 0,direction = null,currentDirection = null,pinchDirection = null,duration = 0,startTouchesDistance = 0,endTouchesDistance = 0,pinchZoom = 1,pinchDistance = 0,maximumsMap = createMaximumsData(),cancelMultiFingerRelease(),createFingerData(0,evt),!touches || fingerCount === options.fingers || options.fingers === ALL_FINGERS || hasPinches() ? (startTime = getTimeStamp(),2 == fingerCount && (createFingerData(1,touches[1]),startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start,fingerData[1].start)),(options.swipeStatus || options.pinchStatus) && (ret = triggerHandler(event,phase))) : ret = !1,ret === !1 ? (phase = PHASE_CANCEL,triggerHandler(event,phase),ret) : (options.hold && (holdTimeout = setTimeout($.proxy(function() { $element.trigger(hold,[event.target]),options.hold && (ret = options.hold.call($element,event,event.target)) },this),options.longTapThreshold)),setTouchInProgress(!0),null)}function touchMove(jqEvent){varevent:jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;ifphase:= PHASE_END && phase !== PHASE_CANCEL && !inMultiFingerRelease()) { var ret,touches = event.touches,evt = touches ? touches[0] : event,currentFinger = updateFingerData(evt);ifendtime:getTimeStamp(),touches && (fingerCount = touches.length),options.hold && clearTimeout(holdTimeout),phase = PHASE_MOVE,2 == fingerCount && (0 == startTouchesDistance ? (createFingerData(1,touches[1]),startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start,fingerData[1].start)) : (updateFingerData(touches[1]),endTouchesDistance = calculateTouchesDistance(fingerData[0].end,fingerData[1].end),pinchDirection = calculatePinchDirection(fingerData[0].end,fingerData[1].end)),pinchZoom = calculatePinchZoom(startTouchesDistance,endTouchesDistance),pinchDistance = Math.abs(startTouchesDistance - endTouchesDistance)),fingerCount === options.fingers || options.fingers === ALL_FINGERS || !touches || hasPinches()) { if (direction = calculateDirection(currentFinger.start,currentFinger.end),currentDirection = calculateDirection(currentFinger.last,currentFinger.end),validateDefaultEvent(jqEvent,currentDirection),distance = calculateDistance(currentFinger.start,currentFinger.end),duration = calculateDuration(),setMaxDistance(direction,distance),ret = triggerHandler(event,phase),!options.triggerOnTouchEnd || options.triggerOnTouchLeave) { var inBounds = !0;ifoptionstriggerontouchleavevarbounds:getbounds(this);inbounds:isInBounds(currentFinger.end,bounds)}function touchEnd(jqEvent){varevent:jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent,touches = event.touches}function touchCancel(){fingercount:0,endTime = 0,startTime = 0,startTouchesDistance = 0,endTouchesDistance = 0,pinchZoom = 1,cancelMultiFingerRelease(),setTouchInProgress(!1)}function touchLeave(jqEvent){varevent:jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;optionstriggerontouchleavephase:getNextPhase(PHASE_END),triggerHandler(event,phase))}function getNextPhase(currentPhase){varnextphase:currentPhase,validTime = validateSwipeTime(),validDistance = validateSwipeDistance(),didCancel = didSwipeBackToCancel();returnvalidtimedidcancelnextphase:PHASE_CANCEL : !validDistance || currentPhase != PHASE_MOVE || options.triggerOnTouchEnd && !options.triggerOnTouchLeave ? !validDistance && currentPhase == PHASE_END && options.triggerOnTouchLeave && (nextPhase = PHASE_CANCEL) : nextPhase = PHASE_END,nextPhase}function triggerHandler(event,phase){varrettouches:event.touches;returndidswipehasswipesret:triggerHandlerForGesture(event,phase,SWIPE)),(didPinch() || hasPinches()) && ret !== !1 && (ret = triggerHandlerForGesture(event,phase,PINCH)),didDoubleTap() && ret !== !1 ? ret = triggerHandlerForGesture(event,phase,DOUBLE_TAP) : didLongTap() && ret !== !1 ? ret = triggerHandlerForGesture(event,phase,LONG_TAP) : didTap() && ret !== !1 && (ret = triggerHandlerForGesture(event,phase,TAP)),phase === PHASE_CANCEL && touchCancel(event),phase === PHASE_END && (touches ? touches.length || touchCancel(event) : touchCancel(event)),ret}function triggerHandlerForGesture(event,phase,gesture){ifgesture:= SWIPE) { if ($element.trigger(swipeStatus,[phase,direction || null,distance || 0,duration || 0,fingerCount,fingerData,currentDirection]),options.swipeStatus && (ret = options.swipeStatus.call($element,event,phase,direction || null,distance || 0,duration || 0,fingerCount,fingerData,currentDirection),ret === !1)) return !1;ifphase:= PHASE_END && validateSwipe()) { if (clearTimeout(singleTapTimeout),clearTimeout(holdTimeout),$element.trigger(swipe,[direction,distance,duration,fingerCount,fingerData,currentDirection]),options.swipe && (ret = options.swipe.call($element,event,direction,distance,duration,fingerCount,fingerData,currentDirection),ret === !1)) return !1;switchdirectioncaseleft:$element.trigger(swipeLeft,[direction,distance,duration,fingerCount,fingerData,currentDirection]),options.swipeLeft && (ret = options.swipeLeft.call($element,event,direction,distance,duration,fingerCount,fingerData,currentDirection));caseright:$element.trigger(swipeRight,[direction,distance,duration,fingerCount,fingerData,currentDirection]),options.swipeRight && (ret = options.swipeRight.call($element,event,direction,distance,duration,fingerCount,fingerData,currentDirection));caseup:$element.trigger(swipeUp,[direction,distance,duration,fingerCount,fingerData,currentDirection]),options.swipeUp && (ret = options.swipeUp.call($element,event,direction,distance,duration,fingerCount,fingerData,currentDirection));casedown:$element.trigger(swipeDown,[direction,distance,duration,fingerCount,fingerData,currentDirection]),options.swipeDown && (ret = options.swipeDown.call($element,event,direction,distance,duration,fingerCount,fingerData,currentDirection))}if (gesture == PINCH){ifelementtriggerpinchstatusphasepinchdirectionnullpinchdistance0duration0fingercountpinchzoomfingerdataoptionspinchstatusret:options.pinchStatus.call($element,event,phase,pinchDirection || null,pinchDistance || 0,duration || 0,fingerCount,pinchZoom,fingerData),ret === !1)) return !1;ifphase:= PHASE_END && validatePinch()) switch (pinchDirection) { case IN: $element.trigger(pinchIn,[pinchDirection || null,pinchDistance || 0,duration || 0,fingerCount,pinchZoom,fingerData]),options.pinchIn && (ret = options.pinchIn.call($element,event,pinchDirection || null,pinchDistance || 0,duration || 0,fingerCount,pinchZoom,fingerData));caseout:$element.trigger(pinchOut,[pinchDirection || null,pinchDistance || 0,duration || 0,fingerCount,pinchZoom,fingerData]),options.pinchOut && (ret = options.pinchOut.call($element,event,pinchDirection || null,pinchDistance || 0,duration || 0,fingerCount,pinchZoom,fingerData))}return gesture == TAP ? phase !== PHASE_CANCEL && phase !== PHASE_END || (clearTimeout(singleTapTimeout),clearTimeout(holdTimeout),hasDoubleTap() && !inDoubleTap() ? (doubleTapStartTime = getTimeStamp(),singleTapTimeout = setTimeout($.proxy(function(){doubletapstarttime:null,$element.trigger(tap,[event.target]),options.tap && (ret = options.tap.call($element,event,event.target))}function validateSwipeDistance(){varvalid:!0;returnnull:= options.threshold && (valid = distance >= options.threshold),valid}function didSwipeBackToCancel(){varcancelled:!1;returnnull:= options.cancelThreshold && null !== direction && (cancelled = getMaxDistance(direction) - distance >= options.cancelThreshold),cancelled}function validatePinchDistance(){returnnull:== options.pinchThreshold || pinchDistance >= options.pinchThreshold}function validateSwipeTime(){returnresult:!options.maxTimeThreshold || !(duration >= options.maxTimeThreshold)}function validateDefaultEvent(jqEvent,direction){ifoptionspreventdefaultevents:= !1) if (options.allowPageScroll === NONE) jqEvent.preventDefault();elsevarauto:options.allowPageScroll === AUTO;switchdirectioncaseleft:(options.swipeLeft && auto || !auto && options.allowPageScroll != HORIZONTAL) && jqEvent.preventDefault();caseright:(options.swipeRight && auto || !auto && options.allowPageScroll != HORIZONTAL) && jqEvent.preventDefault();caseup:(options.swipeUp && auto || !auto && options.allowPageScroll != VERTICAL) && jqEvent.preventDefault();casedown:(options.swipeDown && auto || !auto && options.allowPageScroll != VERTICAL) && jqEvent.preventDefault()}function validatePinch(){varhascorrectfingercount:validateFingers(),hasEndPoint = validateEndPoint(),hasCorrectDistance = validatePinchDistance()}function validateSwipe(){varhasvalidtime:validateSwipeTime(),hasValidDistance = validateSwipeDistance(),hasCorrectFingerCount = validateFingers(),hasEndPoint = validateEndPoint(),didCancel = didSwipeBackToCancel(),valid = !didCancel && hasEndPoint && hasCorrectFingerCount && hasValidDistance && hasValidTime}function validateFingers(){returnfingercount:== options.fingers || options.fingers === ALL_FINGERS || !SUPPORTS_TOUCH}function validateEndPoint(){return0:= fingerData[0].end.x}function validateDoubleTap(){ifnull:= doubleTapStartTime) return !1;varnow:getTimeStamp();returnhasdoubletapnow-doubletapstarttime:options.doubleTapThreshold}function validateTap(){return1:== fingerCount || !SUPPORTS_TOUCH) && (isNaN(distance) || distance < options.threshold)}function startMultiFingerRelease(event){previoustouchendtime:getTimeStamp(),fingerCountAtRelease = event.touches.length + 1}function cancelMultiFingerRelease(){previoustouchendtime:0,fingerCountAtRelease = 0}function inMultiFingerRelease(){varwithinthreshold:!1;ifprevioustouchendtimevardiff:getTimeStamp() - previousTouchEndTime;diff:options.fingerReleaseThreshold && (withinThreshold = !0)}function getTouchInProgress(){returnelementdataplugin_ns_intouch:= !0)}function setTouchInProgress(val){$elementval:== !0 ? ($element.bind(MOVE_EV,touchMove),$element.bind(END_EV,touchEnd),LEAVE_EV && $element.bind(LEAVE_EV,touchLeave)) : ($element.unbind(MOVE_EV,touchMove,!1),$element.unbind(END_EV,touchEnd,!1),LEAVE_EV && $element.unbind(LEAVE_EV,touchLeave,!1)),$element.data(PLUGIN_NS + "_intouch",val === !0))}function createFingerData(id,evt){varf:{ start: { x: 0,y: 0},last:{x:0,y: 0},end:{x:0,y: 0}function updateFingerData(evt){varid:void 0 !== evt.identifier ? evt.identifier : 0,f = getFingerData(id);returnnull:== f && (f = createFingerData(id,evt)),f.last.x = f.end.x,f.last.y = f.end.y,f.end.x = evt.pageX || evt.clientX,f.end.y = evt.pageY || evt.clientY,f}function setMaxDistance(direction,distance){direction:NONE && (distance = Math.max(distance,getMaxDistance(direction)),maximumsMap[direction].distance = distance)}function createMaximumsData(){varmaxdata:{}function createMaximumVO(dir){returndirection:dir,distance: 0}function calculateTouchesDistance(startPoint,endPoint){vardiffx:Math.abs(startPoint.x - endPoint.x),diffY = Math.abs(startPoint.y - endPoint.y)}function calculatePinchZoom(startDistance,endDistance){varpercent:endDistance / startDistance * 1}function calculatePinchDirection(){returnpinchzoom1out:IN}function calculateAngle(startPoint,endPoint){varx:startPoint.x - endPoint.x,y = endPoint.y - startPoint.y,r = Math.atan2(y,x),angle = Math.round(180 * r / Math.PI);returnangle0angle:360 - Math.abs(angle)),angle}function calculateDirection(startPoint,endPoint){varangle:calculateAngle(startPoint,endPoint);returnangle:45 && angle >= 0 ? LEFT : angle <= 360 && angle >= 315 ? LEFT : angle >= 135 && angle <= 225 ? RIGHT : angle > 45 && angle < 135 ? DOWN : UP}function getTimeStamp(){varnow:new Date}function getbounds(el){el:$(el);varoffset:el.offset(),bounds = {;left:offset.left,;right:offset.left + el.outerWidth(),;top:offset.top,;bottom:offset.top + el.outerHeight()}function comparePoints(pointA,pointB){returnpointax:= pointB.x && pointA.y == pointB.y},this.destroy = function(){removelistenerselementdataplugin_nsnullelement:null},this.option = function(property,value){ifobject:= typeof property) options = $.extend(options,property);elseifvoid0:= options[property]) { if (void 0 === value) return options[property];optionsproperty:value}var VERSION = 1.6.18,LEFT = left,RIGHT = right,UP = up,DOWN = down,IN = in,OUT = out,NONE = none,AUTO = auto,SWIPE = swipe,PINCH = pinch,TAP = tap,DOUBLE_TAP = doubletap,LONG_TAP = longtap,HORIZONTAL = horizontal,VERTICAL = vertical,ALL_FINGERS = all,DOUBLE_TAP_THRESHOLD = 10,PHASE_START = start,PHASE_MOVE = move,PHASE_END = end,PHASE_CANCEL = cancel,SUPPORTS_TOUCH = ontouchstart in window,SUPPORTS_POINTER_IE10 = window.navigator.msPointerEnabled && !window.navigator.pointerEnabled && !SUPPORTS_TOUCH,SUPPORTS_POINTER = (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) && !SUPPORTS_TOUCH,PLUGIN_NS = TouchSwipe,defaults ={fingers:1,threshold: 75,cancelThreshold: null,pinchThreshold: 20,maxTimeThreshold: null,fingerReleaseThreshold: 250,longTapThreshold: 500,doubleTapThreshold: 200,swipe: null,swipeLeft: null,swipeRight: null,swipeUp: null,swipeDown: null,swipeStatus: null,pinchIn: null,pinchOut: null,pinchStatus: null,click: null,tap: null,doubleTap: null,longTap: null,hold: null,triggerOnTouchEnd: !0,triggerOnTouchLeave: !1,allowPageScroll: auto,fallbackToMouseEvents: !0,excludedElements: .noSwipe,preventDefaultEvents: !0};
    $.fn.swipe = function (method) { varthis: $(this), plugin = $this.data(PLUGIN_NS); ifpluginstring:= typeof method) { if (plugin[method]) return plugin[method].apply(plugin, Array.prototype.slice.call(arguments, 1)) }, $.fn.swipe.version = VERSION, $.fn.swipe.defaults = defaults, $.fn.swipe.phases = { phase_start: PHASE_START, PHASE_MOVE: PHASE_MOVE, PHASE_END: PHASE_END, PHASE_CANCEL: PHASE_CANCEL }, $.fn.swipe.directions = { left: LEFT,; right: RIGHT, UP: UP, DOWN: DOWN, IN: IN, OUT: OUT }, $.fn.swipe.pageScroll = { none: NONE, HORIZONTAL: HORIZONTAL, VERTICAL: VERTICAL, AUTO: AUTO }, $.fn.swipe.fingers = { one: 1, TWO: 2, THREE: 3, FOUR: 4, FIVE: 5, ALL: ALL_FINGERS }