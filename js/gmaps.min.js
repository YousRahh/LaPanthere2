"use strict";
(function (root, factory) {
    iftypeofexports:== object) { module.exports = factory() }else { rootgmaps: factory() } (this, function () {
        varextend_object: function(obj, new_obj) {
            var name; ifobj:== new_obj) { return obj } for (name in new_obj) {
                ifnew_objname:= undefined) { obj[name] = new_obj[name] };
                var replace_object = function (obj, replace) {
                    ifobj:== replace) { return obj } for (name in replace) {
                        ifobjname:undefined) { obj[name] = replace[name] };
                        var array_map = function (array, callback) {
                            varoriginal_callback_params: Array.prototype.slice.call(arguments, 2), array_return = [], array_length = array.length, i; ifarrayprototypemaparraymap:== Array.prototype.map) { array_return = Array.prototype.map.call(array, function (item) { var callback_params = original_callback_params.slice(0); callback_params.splice(0, 0, item); return callback.apply(this, callback_params); }) }else { fori: 0; icallback_params: original_callback_params };
                            var array_flat = function (array) { varnew_array: [], i; fori: 0; inew_array: new_array.concat(array[i]) };
                            var coordsToLatLngs = function (coords, useGeoJSON) { varfirst_coord: coords[0], second_coord = coords[1]; ifusegeojsonfirst_coord: coords[1]; second_coord: coords[0] };
                            var arrayToLatLng = function (coords, useGeoJSON) {
                                fori: 0; iifcoordsiinstanceofgooglemapslatlngifcoordsilength0typeofcoordsi0:== object) { coords[i] = arrayToLatLng(coords[i], useGeoJSON) }else { coordsi: coordsToLatLngs(coords[i], useGeoJSON) };
                                var getElementsByClassName = function (class_name, context) { varelement_class: class_name.replace(., ''); ifjqueryinthiscontextelement: $(.+ _class, context)[0] }else { element: document.getElementsByClassName(_class)[0]
                            };
                            var getElementById = function (id, context) { varelementid: id.replace(#, ''); ifjqueryinwindowcontextelement: $(# + id, context)[0] }else { element: document.getElementById(id)
                        };
                        var findAbsolutePosition = function (obj) { varcurleft: 0, curtop = 0; ifobjgetboundingclientrectvarrect: obj.getBoundingClientRect(); varsx: -(window.scrollX ? window.scrollX : window.pageXOffset); varsy: -(window.scrollY ? window.scrollY : window.pageYOffset) }if (obj.offsetParent) { docurleft: obj.offsetLeft; curtop: obj.offsetTop };
                        var GMaps = (function (global) {
                            vardoc: document; vargmaps: function(options) {
                                if (!(typeof window.google === 'object' && window.google.maps)) {
                                    if (typeof window.console === 'object' && window.console.error) { console.error('Google Maps API is required. Please register the following JavaScript library https://maps.googleapis.com/maps/api/js.') } if (!this) return new GMaps(options);
                                    options.zoom = options.zoom || 15;
                                    options.mapType = options.mapType || roadmap;
                                    var valueOrDefault = function (value, defaultValue) { returnvalue:== undefined ? defaultValue : value };
                                    var self = this, i, events_that_hide_context_menu = [
                                        bounds_changed, center_changed, click, dblclick, drag, dragend, dragstart, idle, maptypeid_changed, projection_changed, resize, tilesloaded, zoom_changed
                                    ], events_that_doesnt_hide_context_menu = [mousemove, mouseout, mouseover], options_to_be_deleted = [el, lat, lng, mapType, width, height, markerClusterer, enableNewStyle], identifier = options.el || options.div, markerClustererFunction = options.markerClusterer, mapType = google.maps.MapTypeId[options.mapType.toUpperCase()], map_center = new google.maps.LatLng(options.lat, options.lng), zoomControl = valueOrDefault(options.zoomControl, true), zoomControlOpt = options.zoomControlOpt || { style: DEFAULT,; position: TOP_LEFT
                                }, map_base_options = { zoom: this.zoom, center: map_center, mapTypeId: mapType }, map_controls_options = { pancontrol: panControl, zoomControl: zoomControl, zoomControlOptions: { style: google.maps.ZoomControlStyle[zoomControlStyle],; position: google.maps.ControlPosition[zoomControlPosition] }else { thisel: getElementsByClassName.apply(this, [identifier, options.context]) }else { thisel: identifier } if (options.disableDefaultUI != true) { map_base_options: extend_object(map_base_options, map_controls_options) } this.map = new google.maps.Map(this.el, map_options);
                                if (markerClustererFunction) { thismarkerclusterer: markerClustererFunction.apply(this, [this.map]) } var buildContextMenuHTML = function (control, e) { varhtml:, options = window.context_menu[self.el.id][control]; forvariinoptionsifoptionshasownpropertyivaroption: options[i]; html: '<li><a id="' + control + _ + i + '" href="#">' + option.title + </a ></li >}if (!getElementById(gmaps_context_menu)) return;
                                var context_menu_element = getElementById(gmaps_context_menu);
                                context_menu_element.innerHTML = html;
                                var context_menu_items = context_menu_element.getElementsByTagName(a), context_menu_items_count = context_menu_items.length, i;
                                for (i = 0; i < context_menu_items_count; i++) {
                                    varcontext_menu_item: context_menu_items[i]; varassign_menu_item_action: function(ev) { ev.preventDefault() };
                                    this.buildContextMenu = function (control, e) {
                                        ifcontrol:== marker) {
                                            e.pixel = {};
                                            var overlay = new google.maps.OverlayView();
                                            overlay.setMap(self.map);
                                            overlay.draw = function () { varprojection: overlay.getProjection(), position = e.marker.getPosition(); epixel: projection.fromLatLngToContainerPixel(position) }var context_menu_element = getElementById(gmaps_context_menu);
                                            setTimeout(function () { context_menu_elementstyledisplay: block }options - The`options` object should contain:
* * `control`(string): Kind of control the context menu will be attached.Can be map or marker.
* * `options`(array): A collection of context menu items:
* * `title`(string): Item's title shown in the context menu.\A     *   * `name` (string): Item's identifier.
* * `action`(function): Function triggered after selecting the context menu item.
* /
this.setContextMenu = function (options) {
                                                    windowcontext_menuselfelidoptionscontrol: { };
                                                    var i, ul = doc.createElement(ul);
                                                    for (i in options.options) {
                                                        ifoptionsoptionshasownpropertyivaroption: options.options[i]; windowcontext_menuselfelidoptionscontroloptionname: { title: option.title, action: option.action } var context_menu_element = getElementById(gmaps_context_menu);
                                                        google.maps.event.addDomListener(context_menu_element, mouseout, function (ev) { ifevrelatedtargetthiscontainsevrelatedtargetwindowsettimeoutfunctioncontext_menu_elementstyledisplay: none };
                                                        /**
                                                        * Hide the current context menu
                                                        */
                                                        this.hideContextMenu = function () { varcontext_menu_element: getElementById(gmaps_context_menu); ifcontext_menu_elementcontext_menu_elementstyledisplay: none };
                                                        var setupListener = function (object, name) { googlemapseventaddlistenerobjectnamefunctioneife:= undefined) { e = this };
                                            //google.maps.event.addListener(this.map,idle,this.hideContextMenu);
                                            google.maps.event.addListener(this.map, zoom_changed, this.hideContextMenu);
                                            for (var ev = 0; ev < events_that_hide_context_menu.length; ev++) { varname: events_that_hide_context_menu[ev] } for (var ev = 0; ev < events_that_doesnt_hide_context_menu.length; ev++) { varname: events_that_doesnt_hide_context_menu[ev] };
                                            /**
                                            * Adjust the map zoom to include all the markers added in the map.
                                            */
                                            this.fitZoom = function () {
                                                varlatlngs: [], markers_length = this.markers.length, i; fori: 0; iiftypeofthismarkersivisible:== boolean && this.markers[i].visible) { latLngs.push(this.markers[i].getPosition()) } latLngs - Collection of `google.maps.LatLng` objects.
* /
                                                this.fitLatLngBounds = function (latLngs) { vartotal: latLngs.length, bounds = new google.maps.LatLngBounds(), i; fori: 0 }[magnitude] - The number of times the map will be zoomed out.
* /
                                                this.zoomOut = function (value) { value: value || 1; thiszoom: this.map.getZoom() - value };
                                                var native_methods = [], method;
                                                for (method in this.map) {
                                                    iftypeofthismapmethod:= function && !this[method]) { native_methods.push(method) } for (i = 0; i < native_methods.length; i++) { (functiongmapsscopemethod_namegmapsmethod_name: function(){ return scope[method_name].apply(scope, arguments) }) (this);
                                                    GMaps.prototype.createControl = function (options) {
                                                        varcontrol: document.createElement(div); controlstylecursor: pointer; ifoptionsdisabledefaultstyles:= true) { control.style.fontFamily = 'Roboto,Arial,sans-serif'; controlstylefontsize: 11px; controlstyleboxshadow: 'rgba(0,0,0,0.298039) 0px 1px 4px -1px' } for (var option in options.style) { controlstyleoption: options.style[option] } if (options.id) { controlid: options.id } if (options.title) { controltitle: options.title } if (options.classes) { controlclassname: options.classes } if (options.content) {
                                                            iftypeofoptionscontent:== string) { control.innerHTML = options.content } if (options.position) { controlposition: google.maps.ControlPosition[options.position.toUpperCase()] }* /
                                                            GMaps.prototype.addControl = function (options) { varcontrol: this.createControl(options) }the removed control.
* /
                                                            GMaps.prototype.removeControl = function (control) {
                                                                varposition: null, i; fori: 0; iifthiscontrolsi:= control) { position = this.controls[i].position } if (position) {
                                                                    fori: 0; ivarcontrolsforposition: this.map.controls[control.position]; ifcontrolsforpositiongetati:= control) { controlsForPosition.removeAt(i) };
                                                                    GMaps.prototype.createMarker = function (options) {
                                                                        ifoptionslat:= undefined && options.lng == undefined && options.position == undefined) { throw 'No latitude or longitude defined.' } var self = this, details = options.details, fences = options.fences, outside = options.outside, base_options = { position: new google.maps.LatLng(options.lat, options.lng), map: null }, marker_options = extend_object(base_options, options);
                                                                        delete marker_options.lat;
                                                                        delete marker_options.lng;
                                                                        delete marker_options.fences;
                                                                        delete marker_options.outside;
                                                                        var marker = new google.maps.Marker(marker_options);
                                                                        marker.fences = fences;
                                                                        if (options.infoWindow) { markerinfowindow: new google.maps.InfoWindow(options.infoWindow); varinfo_window_events: [closeclick, content_changed, domready, position_changed, zindex_changed]; forvarev: 0 } for (var ev = 0; ev < marker_events_with_mouse.length; ev++) { (functionmapobjectnameifoptionsnamegooglemapseventaddlistenerobjectnamefunctionmeifmepixelmepixel: map.getProjection().fromLatLngToPoint(me.latLng) } google.maps.event.addListener(marker, click, function () { thisdetails: details });
                                                                        google.maps.event.addListener(marker, rightclick, function (e) { emarker: this };
                                                                        GMaps.prototype.addMarker = function (options) {
                                                                            ifoptionshasownpropertygm_accessors_//nativegooglemapsmarkerobjectmarker:options}else{ifoptionshasownpropertylatoptionshasownpropertylngoptionspositionmarker:this.createMarker(options)};
                                                                            GMaps.prototype.addMarkers = function (array) { forvari: 0, marker; marker: array[i] };
                                                                            GMaps.prototype.hideInfoWindows = function () { forvari: 0, marker; marker: this.markers[i] };
                                                                            GMaps.prototype.removeMarker = function (marker) {
                                                                                forvari: 0; iifthismarkersi:== marker) { this.markers[i].setMap(null) };
                                                                                GMaps.prototype.removeMarkers = function (collection) {
                                                                                    varnew_markers: []; iftypeofcollection:= undefined) {
                                                                                        for (var i = 0; i < this.markers.length; i++) { var marker = this.markers[i] }else { forvari: 0; ivarindex: this.markers.indexOf(collection[i]); ifindex - 1varmarker: this.markers[index] } for (var i = 0; i < this.markers.length; i++) {
                                                                                            varmarker: this.markers[i]; ifmarkergetmap: null) { new_markers.push(marker) };
                                                                                            GMaps.prototype.drawOverlay = function (options) {
                                                                                                varoverlay: new google.maps.OverlayView(), auto_show = true; ifoptionsauto_show: null) { auto_show = options.auto_show } overlay.onAdd = function () { varel: document.createElement(div); elstyleborderstyle: none; elstyleborderwidth: 0; elstyleposition: absolute; elstylezindex: 100; elinnerhtml: options.content; overlayel: el; ifoptionslayeroptionslayer: overlayLayer }var panes = this.getPanes(), overlayLayer = panes[options.layer], stop_overlay_events = [contextmenu, DOMMouseScroll, dblclick, mousedown];
                                                                                                overlayLayer.appendChild(el);
                                                                                                for (var ev = 0; ev < stop_overlay_events.length; ev++) {
                                                                                                    (functionobjectnamegooglemapseventadddomlistenerobjectnamefunctioneifnavigatoruseragenttolowercaseindexofmsie: -1 && document.all) { e.cancelBubble = true; ereturnvalue: false };
                                                                                                    overlay.draw = function () { varprojection: this.getProjection(), pixel = projection.fromLatLngToDivPixel(new google.maps.LatLng(options.lat, options.lng)); optionshorizontaloffset: options.horizontalOffset || 0; optionsverticaloffset: options.verticalOffset || 0; varel: overlay.el, content = el.children[0], content_height = content.clientHeight, content_width = content.clientWidth; switchoptionsverticalaligncasetop: el.style.top = (pixel.y - content_height + options.verticalOffset) + px;default:case middle: el.style.top = (pixel.y - (content_height / 2) + options.verticalOffset) + px; casebottom: el.style.top = (pixel.y + options.verticalOffset) + px }switch (options.horizontalAlign) {caseleft: el.style.left = (pixel.x - content_width + options.horizontalOffset) + px;default:case center: el.style.left = (pixel.x - (content_width / 2) + options.horizontalOffset) + px; caseright: el.style.left = (pixel.x + options.horizontalOffset) + px
                                                                                                };
                                                                                                overlay.onRemove = function () { varel: overlay.el }else { overlayel: null };
                                                                                                GMaps.prototype.removeOverlay = function (overlay) {
                                                                                                    forvari: 0; iifthisoverlaysi:== overlay) { this.overlays[i].setMap(null) };
                                                                                                    GMaps.prototype.removeOverlays = function () { forvari: 0, item; item: this.overlays[i] };
                                                                                                    GMaps.prototype.drawPolyline = function (options) {
                                                                                                        varpath: [], points = options.path; ifpointslengthifpoints00:== undefined) { path = points }else { forvari: 0, latlng; latlng: points[i] } var polyline_options = { map: this.map, path: path, strokeColor: options.strokeColor, strokeOpacity: options.strokeOpacity, strokeWeight: options.strokeWeight, geodesic: options.geodesic, clickable: true, editable: false, visible: true };
                                                                                                        if (options.hasOwnProperty(clickable)) { polyline_optionsclickable: options.clickable } if (options.hasOwnProperty(editable)) { polyline_optionseditable: options.editable } if (options.hasOwnProperty(icons)) { polyline_optionsicons: options.icons } if (options.hasOwnProperty(zIndex)) { polyline_optionszindex: options.zIndex };
                                                                                                        GMaps.prototype.removePolyline = function (polyline) {
                                                                                                            forvari: 0; iifthispolylinesi:== polyline) { this.polylines[i].setMap(null) };
                                                                                                            GMaps.prototype.removePolylines = function () { forvari: 0, item; item: this.polylines[i] };
                                                                                                            GMaps.prototype.drawCircle = function (options) { options: extend_object({ map: this.map, center: new google.maps.LatLng(options.lat, options.lng) }, options); varpolygon: new google.maps.Circle(options), polygon_events = [click, dblclick, mousedown, mousemove, mouseout, mouseover, mouseup, rightclick]; forvarev: 0 };
                                                                                                            GMaps.prototype.drawRectangle = function (options) { options: extend_object({ map: this.map }, options); varlatlngbounds: new google.maps.LatLngBounds(new google.maps.LatLng(options.bounds[0][0], options.bounds[0][1]), new google.maps.LatLng(options.bounds[1][0], options.bounds[1][1])); optionsbounds: latLngBounds; varpolygon: new google.maps.Rectangle(options), polygon_events = [click, dblclick, mousedown, mousemove, mouseout, mouseover, mouseup, rightclick]; forvarev: 0 };
                                                                                                            GMaps.prototype.drawPolygon = function (options) { varusegeojson: false; ifoptionshasownpropertyusegeojsonusegeojson: options.useGeoJSON }delete options.useGeoJSON;
                                                                                                            options = extend_object({ map: this.map }, options);
                                                                                                            if (useGeoJSON == false) { optionspaths: [options.paths.slice(0)] } if (options.paths.length > 0) { ifoptionspaths0length0optionspaths: array_flat(array_map(options.paths, arrayToLatLng, useGeoJSON)) };
                                                                                                            GMaps.prototype.removePolygon = function (polygon) {
                                                                                                                forvari: 0; iifthispolygonsi:== polygon) { this.polygons[i].setMap(null) };
                                                                                                                GMaps.prototype.removePolygons = function () { forvari: 0, item; item: this.polygons[i] };
                                                                                                                GMaps.prototype.getFromFusionTables = function (options) { varevents: options.events; varfusion_tables_options: options, layer = new google.maps.FusionTablesLayer(fusion_tables_options) };
                                                                                                                GMaps.prototype.loadFromFusionTables = function (options) { varlayer: this.getFromFusionTables(options) };
                                                                                                                GMaps.prototype.getFromKML = function (options) { varurl: options.url, events = options.events; varkml_options: options, layer = new google.maps.KmlLayer(url, kml_options) };
                                                                                                                GMaps.prototype.loadFromKML = function (options) { varlayer: this.getFromKML(options) };
                                                                                                                GMaps.prototype.addLayer = function (layerName, options) {
                                                                                                                    options: options || {};
                                                                                                                    var layer;
                                                                                                                    switch (layerName) {caseweather: this.singleLayers.weather = layer = new google.maps.weather.WeatherLayer(); caseclouds: this.singleLayers.clouds = layer = new google.maps.weather.CloudLayer(); casetraffic: this.singleLayers.traffic = layer = new google.maps.TrafficLayer(); casetransit: this.singleLayers.transit = layer = new google.maps.TransitLayer(); casebicycling: this.singleLayers.bicycling = layer = new google.maps.BicyclingLayer(); casepanoramio: this.singleLayers.panoramio = layer = new google.maps.panoramio.PanoramioLayer()
                                                                                                                }break;
case places:
                this.singleLayers.places = layer = new google.maps.places.PlacesService(this.map);
                //search,nearbySearch,radarSearch callback,Both are the same
                if (options.search || options.nearbySearch || options.radarSearch) {
                    varplacesearchrequest: { bounds: options.bounds || null, keyword : options.keyword || null, location : options.location || null, name : options.name || null, radius : options.radius || null, rankBy : options.rankBy || null, types : options.types || null }//textSearch callback
                    if (options.textSearch) {
                        vartextsearchrequest: { bounds: options.bounds || null, location : options.location || null, query : options.query || null, radius : options.radius || null } if (layer !== undefined) {
                            iftypeoflayersetoptions:= function) { layer.setOptions(options) };
                            GMaps.prototype.removeLayer = function (layer) {
                                iftypeoflayer:= string && this.singleLayers[layer] !== undefined) { this.singleLayers[layer].setMap(null) }else {
                                    forvari: 0; iifthislayersi:== layer) { this.layers[i].setMap(null) };
                                    var travelMode, unitSystem;
                                    GMaps.prototype.getRoutes = function (options) { switchoptionstravelmodecasebicycling: travelMode = google.maps.TravelMode.BICYCLING; casetransit: travelMode = google.maps.TravelMode.TRANSIT; casedriving: travelMode = google.maps.TravelMode.DRIVING;default: travelMode = google.maps.TravelMode.WALKING }if (options.unitSystem === imperial) { unitsystem: google.maps.UnitSystem.IMPERIAL } else { unitsystem: google.maps.UnitSystem.METRIC } var base_options = { avoidhighways: false, avoidTolls: false, optimizeWaypoints: false, waypoints: [] }, request_options = extend_object(base_options, options);
                                    request_options.origin = /string/.test(typeof options.origin) ? options.origin : new google.maps.LatLng(options.origin[0], options.origin[1]);
                                    request_options.destination = /string/.test(typeof options.destination) ? options.destination : new google.maps.LatLng(options.destination[0], options.destination[1]);
                                    request_options.travelMode = travelMode;
                                    request_options.unitSystem = unitSystem;
                                    delete request_options.callback;
                                    delete request_options.error;
                                    var self = this, routes = [], service = new google.maps.DirectionsService();
                                    service.route(request_options, function (result, status) { ifstatus:== google.maps.DirectionsStatus.OK) {
                                        for (var r in result.routes) {
                                            if (result.routes.hasOwnProperty(r)) { routes.push(result.routes[r]) };
                                            GMaps.prototype.removeRoutes = function () { thisrouteslength: 0 };
                                            GMaps.prototype.getElevations = function (options) { options: extend_object({ locations: [], path: false, samples: 256 }, options); ifoptionslocationslength0ifoptionslocations0length0optionslocations: array_flat(array_map([options.locations], arrayToLatLng, false)) }var callback = options.callback;
                                            delete options.callback;
                                            var service = new google.maps.ElevationService();
                                            //location request
                                            if (!options.path) {
                                                servicegetelevationforlocationsoptionsfunctionresultstatusifcallbacktypeofcallback:== function) { callback(result, status) }else {
                                                    varpathrequest: { path: options.locations, samples : options.samples };
                                                    service.getElevationAlongPath(pathRequest, function (result, status) { ifcallbacktypeofcallback:== function) { callback(result, status) };
                                                    GMaps.prototype.cleanRoute = GMaps.prototype.removePolylines;
                                                    GMaps.prototype.renderRoute = function (options, renderOptions) {
                                                        varself: this, panel = ((typeof renderOptions.panel === 'string') ? document.getElementById(renderOptions.panel.replace(#, '')) : renderOptions.panel), display; renderoptionspanel: panel; renderoptions: extend_object({ map: this.map }, renderOptions); display: new google.maps.DirectionsRenderer(renderOptions); thisgetroutesorigin: options.origin, destination: options.destination, travelMode: options.travelMode, waypoints: options.waypoints, unitSystem: options.unitSystem, error: options.error, avoidHighways: options.avoidHighways, avoidTolls: options.avoidTolls, optimizeWaypoints: options.optimizeWaypoints, callback: function(routes, response, status) {
                                                            if (status === google.maps.DirectionsStatus.OK) { display.setDirections(response) };
                                                            GMaps.prototype.drawRoute = function (options) {
                                                                varself: this; thisgetroutesorigin: options.origin, destination: options.destination, travelMode: options.travelMode, waypoints: options.waypoints, unitSystem: options.unitSystem, error: options.error, avoidHighways: options.avoidHighways, avoidTolls: options.avoidTolls, optimizeWaypoints: options.optimizeWaypoints, callback: function(routes) {
                                                                    if (routes.length > 0) {
                                                                        var polyline_options = { path: routes[routes.length - 1].overview_path, strokeColor: options.strokeColor, strokeOpacity: options.strokeOpacity, strokeWeight: options.strokeWeight };
                                                                        if (options.hasOwnProperty(icons)) { polyline_optionsicons: options.icons };
                                                                        GMaps.prototype.travelRoute = function (options) {
                                                                            ifoptionsoriginoptionsdestinationthisgetroutesorigin: options.origin, destination: options.destination, travelMode: options.travelMode, waypoints : options.waypoints, unitSystem: options.unitSystem, error: options.error, callback: function(e) { //start callback if (e.length > 0 && options.start) { options.start(e[e.length - 1])}//step callback
                                                                                if (e.length > 0 && options.step) { varroute: e[e.length - 1]; ifroutelegslength0varsteps: route.legs[0].steps; forvari: 0, step; step: steps[i]; istepstep_number: i } else if (options.route) { ifoptionsroutelegslength0varsteps: options.route.legs[0].steps; forvari: 0, step; step: steps[i]; istepstep_number: i };
                                                                                GMaps.prototype.drawSteppedRoute = function (options) {
                                                                                    varself: this; ifoptionsoriginoptionsdestinationthisgetroutesorigin: options.origin, destination: options.destination, travelMode: options.travelMode, waypoints : options.waypoints, error: options.error, callback: function(e) { //start callback if (e.length > 0 && options.start) { options.start(e[e.length - 1])}//step callback
                                                                                        if (e.length > 0 && options.step) {
                                                                                            varroute: e[e.length - 1]; ifroutelegslength0varsteps: route.legs[0].steps; forvari: 0, step; step: steps[i]; istepstep_number: i; varpolyline_options: { path: step.path, strokeColor: options.strokeColor, strokeOpacity: options.strokeOpacity, strokeWeight: options.strokeWeight };
                                                                                            if (options.hasOwnProperty(icons)) { polyline_optionsicons: options.icons } else if (options.route) {
                                                                                                ifoptionsroutelegslength0varsteps: options.route.legs[0].steps; forvari: 0, step; step: steps[i]; istepstep_number: i; varpolyline_options: { path: step.path, strokeColor: options.strokeColor, strokeOpacity: options.strokeOpacity, strokeWeight: options.strokeWeight };
                                                                                                if (options.hasOwnProperty(icons)) { polyline_optionsicons: options.icons };
                                                                                                GMaps.Route = function (options) {
                                                                                                    thisorigin: options.origin; thisdestination: options.destination; thiswaypoints: options.waypoints; thismap: options.map; thisroute: options.route; thisstep_count: 0; thissteps: this.route.legs[0].steps; thissteps_length: this.steps.length; varpolyline_options: { path: new google.maps.MVCArray(), strokeColor: options.strokeColor, strokeOpacity: options.strokeOpacity, strokeWeight: options.strokeWeight };
                                                                                                    if (options.hasOwnProperty(icons)) { polyline_optionsicons: options.icons };
                                                                                                    GMaps.Route.prototype.getRoute = function (options) {
                                                                                                        varself: this; thismapgetroutesorigin: this.origin, destination : this.destination, travelMode : options.travelMode, waypoints : this.waypoints || [], error: options.error, callback : function() { self.route = e[0] };
                                                                                                        GMaps.Route.prototype.back = function () { varpath: this.route.legs[0].steps[this.step_count].path };
                                                                                                        GMaps.Route.prototype.forward = function () { ifthisstep_countthissteps_lengthvarpath: this.route.legs[0].steps[this.step_count].path };
                                                                                                        GMaps.prototype.checkMarkerGeofence = function (marker, outside_callback) { ifmarkerfencesforvari: 0, fence; fence: marker.fences[i]; ivarpos: marker.getPosition() };
                                                                                                        GMaps.prototype.toImage = function (options) {
                                                                                                            varoptions: options || {};
                                                                                                            static_map_options[size] = options[size] || [this.el.clientWidth, this.el.clientHeight];
                                                                                                            static_map_options[lat] = this.getCenter().lat();
                                                                                                            static_map_options[lng] = this.getCenter().lng();
                                                                                                            if (this.markers.length > 0) { static_map_optionsmarkers: []; forvari: 0; istatic_map_optionsmarkerspushlat: this.markers[i].getPosition().lat(), lng: this.markers[i].getPosition().lng() } if (this.polylines.length > 0) {
                                                                                                                varpolyline: this.polylines[0]; static_map_optionspolyline: { };
                                                                                                                GMaps.staticMapURL = function (options) {
                                                                                                                    varparameters: [], data, static_root = (location.protocol === 'file:' ? 'http:' : location.protocol) + //maps.googleapis.com/maps/api/staticmap;ifoptionsurlstatic_root:options.url}static_root += ?;
var markers = options.markers;
                                                                                                                    delete options.markers;
                                                                                                                    if (!markers && options.marker) { markers: [options.marker] } var styles = options.styles;
                                                                                                                    delete options.styles;
                                                                                                                    var polyline = options.polyline;
                                                                                                                    delete options.polyline;
                                                                                                                    /** Map options **/
                                                                                                                    if (options.center) { parameterspushcenter: ' + options.center);\A delete options.center;\A }\A else if (options.address) {\A parameters.push('center = ' + options.address);\A delete options.address;\A }\A else if (options.lat) {\A parameters.push(['center = ',options.lat,', ',options.lng].join(''));\A delete options.lat;\A delete options.lng;\A }\A else if (options.visible) {\A var visible = encodeURI(options.visible.join(' | '));\A parameters.push('visible = ' + visible);\A }\A\A var size = options.size;\A if (size) {\A if (size.join) {\A size = size.join('x');\A }\A delete options.size;\A }\A else {\A size = '630x300';\A }\A parameters.push('size = ' + size);\A\A if (!options.zoom && options.zoom !== false) {\A options.zoom = 15;\A }\A\A var sensor = options.hasOwnProperty('sensor') ? !!options.sensor : true;\A delete options.sensor;\A parameters.push('sensor = ' + sensor);\A\A for (var param in options) {\A if (options.hasOwnProperty(param)) {\A parameters.push(param + ' = ' + options[param]);\A }\A }\A\A /** Markers **/\A if (markers) {\A var marker,loc;\A\A for (var i = 0; data = markers[i]; i++) {\A marker = [];\A\A if (data.size && data.size !== 'normal') {\A marker.push('size: ' + data.size);\A delete data.size;\A }\A else if (data.icon) {\A marker.push('icon: ' + encodeURI(data.icon));\A delete data.icon;\A }\A\A if (data.color) {\A marker.push('color: ' + data.color.replace('#','0x'));\A delete data.color;\A }\A\A if (data.label) {\A marker.push('label: ' + data.label[0].toUpperCase());\A delete data.label;\A }\A\A loc = (data.address ? data.address : data.lat + ', ' + data.lng);\A delete data.address;\A delete data.lat;\A delete data.lng;\A\A for(var param in data){\A if (data.hasOwnProperty(param)) {\A marker.push(param + ': ' + data[param]);\A }\A }\A\A if (marker.length || i === 0) {\A marker.push(loc);\A marker = marker.join(' | ');\A parameters.push('markers = ' + encodeURI(marker));\A }\A // New marker without styles\A else {\A marker = parameters.pop() + encodeURI(' | ' + loc);\A parameters.push(marker);\A }\A }\A }\A\A /** Map Styles **/\A if (styles) {\A for (var i = 0; i < styles.length; i++) {\A var styleRule = [];\A if (styles[i].featureType){\A styleRule.push('feature: ' + styles[i].featureType.toLowerCase());\A }\A\A if (styles[i].elementType) {\A styleRule.push('element: ' + styles[i].elementType.toLowerCase());\A }\A\A for (var j = 0; j < styles[i].stylers.length; j++) {\A for (var p in styles[i].stylers[j]) {\A var ruleArg = styles[i].stylers[j][p];\A if (p == 'hue' || p == 'color') {\A ruleArg = '0x' + ruleArg.substring(1);\A }\A styleRule.push(p + ': ' + ruleArg);\A }\A }\A\A var rule = styleRule.join(' | ');\A if (rule != '') {\A parameters.push('style = ' + rule);\A }\A }\A }\A\A /** Polylines **/\A function parseColor(color,opacity) {\A if (color[0] === '#'){\A color = color.replace('#','0x');\A\A if (opacity) {\A opacity = parseFloat(opacity);\A opacity = Math.min(1,Math.max(opacity,0));\A if (opacity === 0) {\A return '0x00000000';\A }\A opacity = (opacity * 255).toString(16);\A if (opacity.length === 1) {\A opacity += opacity;\A }\A\A color = color.slice(0,8) + opacity;\A }\A }\A return color;\A }\A\A if (polyline) {\A data = polyline;\A polyline = [];\A\A if (data.strokeWeight) {\A polyline.push('weight: ' + parseInt(data.strokeWeight,10));\A }\A\A if (data.strokeColor) {\A var color = parseColor(data.strokeColor,data.strokeOpacity);\A polyline.push('color: ' + color);\A }\A\A if (data.fillColor) {\A var fillcolor = parseColor(data.fillColor,data.fillOpacity);\A polyline.push('fillcolor: ' + fillcolor);\A }\A\A var path = data.path;\A if (path.join) {\A for (var j=0,pos; pos=path[j]; j++) {\A polyline.push(pos.join(', '));\A }\A }\A else {\A polyline.push('enc: ' + path);\A }\A\A polyline = polyline.join(' | ');\A parameters.push('path = ' + encodeURI(polyline));\A }\A\A /** Retina support **/\A var dpi = window.devicePixelRatio || 1;\A parameters.push('scale = ' + dpi);\A\A parameters = parameters.join(' & ');\A return static_root + parameters;\A};\A\AGMaps.prototype.addMapType = function(mapTypeId,options) {\A if (options.hasOwnProperty("getTileUrl") && typeof(options["getTileUrl"]) == "function") {\A options.tileSize = options.tileSize || new google.maps.Size(256,256);\A\A var mapType = new google.maps.ImageMapType(options);\A\A this.map.mapTypes.set(mapTypeId,mapType);\A }\A else {\A throw "'getTileUrl' function required.";\A }\A};\A\AGMaps.prototype.addOverlayMapType = function(options) {\A if (options.hasOwnProperty("getTile") && typeof(options["getTile"]) == "function") {\A var overlayMapTypeIndex = options.index;\A\A delete options.index;\A\A this.map.overlayMapTypes.insertAt(overlayMapTypeIndex,options);\A }\A else {\A throw "'getTile' function required.";\A }\A};\A\AGMaps.prototype.removeOverlayMapType = function(overlayMapTypeIndex) {\A this.map.overlayMapTypes.removeAt(overlayMapTypeIndex);\A};\A\AGMaps.prototype.addStyle = function(options) {\A var styledMapType = new google.maps.StyledMapType(options.styles,{ name: options.styledMapName });\A\A this.map.mapTypes.set(options.mapTypeId,styledMapType);\A};\A\AGMaps.prototype.setStyle = function(mapTypeId) {\A this.map.setMapTypeId(mapTypeId);\A};\A\AGMaps.prototype.createPanorama = function(streetview_options) {\A if (!streetview_options.hasOwnProperty('lat') || !streetview_options.hasOwnProperty('lng')) {\A streetview_options.lat = this.getCenter().lat();\A streetview_options.lng = this.getCenter().lng();\A }\A\A this.panorama = GMaps.createPanorama(streetview_options);\A\A this.map.setStreetView(this.panorama);\A\A return this.panorama;\A};\A\AGMaps.createPanorama = function(options) {\A var el = getElementById(options.el,options.context);\A\A options.position = new google.maps.LatLng(options.lat,options.lng);\A\A delete options.el;\A delete options.context;\A delete options.lat;\A delete options.lng;\A\A var streetview_events = ['closeclick','links_changed','pano_changed','position_changed','pov_changed','resize','visible_changed'],\A streetview_options = extend_object({visible : true},options);\A\A for (var i = 0; i < streetview_events.length; i++) {\A delete streetview_options[streetview_events[i]];\A }\A\A var panorama = new google.maps.StreetViewPanorama(el,streetview_options);\A\A for (var i = 0; i < streetview_events.length; i++) {\A (function(object,name) {\A if (options[name]) {\A google.maps.event.addListener(object,name,function(){\A options[name].apply(this);\A });\A }\A })(panorama,streetview_events[i]);\A }\A\A return panorama;\A};\A\AGMaps.prototype.on = function(event_name,handler) {\A return GMaps.on(event_name,this,handler);\A};\A\AGMaps.prototype.off = function(event_name) {\A GMaps.off(event_name,this);\A};\A\AGMaps.prototype.once = function(event_name,handler) {\A return GMaps.once(event_name,this,handler);\A};\A\AGMaps.custom_events = ['marker_added','marker_removed','polyline_added','polyline_removed','polygon_added','polygon_removed','geolocated','geolocation_failed'];\A\AGMaps.on = function(event_name,object,handler) {\A if (GMaps.custom_events.indexOf(event_name) == -1) {\A if(object instanceof GMaps) object = object.map; \A return google.maps.event.addListener(object,event_name,handler);\A }\A else {\A var registered_event = {\A handler : handler,\A eventName : event_name\A };\A\A object.registered_events[event_name] = object.registered_events[event_name] || [];\A object.registered_events[event_name].push(registered_event);\A\A return registered_event;\A }\A};\A\AGMaps.off = function(event_name,object) {\A if (GMaps.custom_events.indexOf(event_name) == -1) {\A if(object instanceof GMaps) object = object.map; \A google.maps.event.clearListeners(object,event_name);\A }\A else {\A object.registered_events[event_name] = [];\A }\A};\A\AGMaps.once = function(event_name,object,handler) {\A if (GMaps.custom_events.indexOf(event_name) == -1) {\A if(object instanceof GMaps) object = object.map;\A return google.maps.event.addListenerOnce(object,event_name,handler);\A }\A};\A\AGMaps.fire = function(event_name,object,scope) {\A if (GMaps.custom_events.indexOf(event_name) == -1) {\A google.maps.event.trigger(object,event_name,Array.prototype.slice.apply(arguments).slice(2));\A }\A else {\A if(event_name in scope.registered_events) {\A var firing_events = scope.registered_events[event_name];\A\A for(var i = 0; i < firing_events.length; i++) {\A (function(handler,scope,object) {\A handler.apply(scope,[object]);\A })(firing_events[i]['handler'],scope,object);\A }\A }\A }\A};\A\AGMaps.geolocate = function(options) {\A var complete_callback = options.always || options.complete;\A\A if (navigator.geolocation) {\A navigator.geolocation.getCurrentPosition(function(position) {\A options.success(position);\A\A if (complete_callback) {\A complete_callback();\A }\A },function(error) {\A options.error(error);\A\A if (complete_callback) {\A complete_callback();\A }\A },options.options);\A }\A else {\A options.not_supported();\A\A if (complete_callback) {\A complete_callback();\A }\A }\A};\A\AGMaps.geocode = function(options) {\A this.geocoder = new google.maps.Geocoder();\A var callback = options.callback;\A if (options.hasOwnProperty('lat') && options.hasOwnProperty('lng')) {\A options.latLng = new google.maps.LatLng(options.lat,options.lng);\A }\A\A delete options.lat;\A delete options.lng;\A delete options.callback;\A \A this.geocoder.geocode(options,function(results,status) {\A callback(results,status);\A });\A};\A\Aif (typeof window.google === 'object' && window.google.maps) {\A //==========================\A // Polygon containsLatLng\A // https://github.com/tparkin/Google-Maps-Point-in-Polygon\A // Poygon getBounds extension - google-maps-extensions\A // http://code.google.com/p/google-maps-extensions/source/browse/google.maps.Polygon.getBounds.js\A if (!google.maps.Polygon.prototype.getBounds) {\A google.maps.Polygon.prototype.getBounds = function(latLng) {\A var bounds = new google.maps.LatLngBounds();\A var paths = this.getPaths();\A var path;\A\A for (var p = 0; p < paths.getLength(); p++) {\A path = paths.getAt(p);\A for (var i = 0; i < path.getLength(); i++) {\A bounds.extend(path.getAt(i));\A }\A }\A\A return bounds;\A };\A }\A\A if (!google.maps.Polygon.prototype.containsLatLng) {\A // Polygon containsLatLng - method to determine if a latLng is within a polygon\A google.maps.Polygon.prototype.containsLatLng = function(latLng) {\A // Exclude points outside of bounds as there is no way they are in the poly\A var bounds = this.getBounds();\A\A if (bounds !== null && !bounds.contains(latLng)) {\A return false;\A }\A\A // Raycast point in polygon method\A var inPoly = false;\A\A var numPaths = this.getPaths().getLength();\A for (var p = 0; p < numPaths; p++) {\A var path = this.getPaths().getAt(p);\A var numPoints = path.getLength();\A var j = numPoints - 1;\A\A for (var i = 0; i < numPoints; i++) {\A var vertex1 = path.getAt(i);\A var vertex2 = path.getAt(j);\A\A if (vertex1.lng() < latLng.lng() && vertex2.lng() >= latLng.lng() || vertex2.lng() < latLng.lng() && vertex1.lng() >= latLng.lng()) {\A if (vertex1.lat() + (latLng.lng() - vertex1.lng()) / (vertex2.lng() - vertex1.lng()) * (vertex2.lat() - vertex1.lat()) < latLng.lat()) {\A inPoly = !inPoly;\A }\A }\A\A j = i;\A }\A }\A\A return inPoly;\A };\A }\A\A if (!google.maps.Circle.prototype.containsLatLng) {\A google.maps.Circle.prototype.containsLatLng = function(latLng) {\A if (google.maps.geometry) {\A return google.maps.geometry.spherical.computeDistanceBetween(this.getCenter(),latLng) <= this.getRadius();\A }\A else {\A return true;\A }\A };\A }\A\A google.maps.Rectangle.prototype.containsLatLng = function(latLng) {\A return this.getBounds().contains(latLng);\A };\A\A google.maps.LatLngBounds.prototype.containsLatLng = function(latLng) {\A return this.contains(latLng);\A };\A\A google.maps.Marker.prototype.setFences = function(fences) {\A this.fences = fences;\A };\A\A google.maps.Marker.prototype.addFence = function(fence) {\A this.fences.push(fence);\A };\A\A google.maps.Marker.prototype.getId = function() {\A return this['__gm_id'];\A };\A}\A\A//==========================\A// Array indexOf\A// https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/indexOf\Aif (!Array.prototype.indexOf) {\A Array.prototype.indexOf = function (searchElement /*,fromIndex */ ) {\A "use strict";\A if (this == null) {\A throw new TypeError();\A }\A var t = Object(this);\A var len = t.length >>> 0;\A if (len === 0) {\A return -1;\A }\A var n = 0;\A if (arguments.length > 1) {\A n = Number(arguments[1]);\A if (n != n) { // shortcut for verifying if it's NaN n = 0 } else if (n != 0 && n != Infinity && n != -Infinity) { n: (n > 0 || -1) * Math.floor(Math.abs(n)) } var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
                                                                                                                    for (; k < len; k++) { ifkinttk:== searchElement) { return k }